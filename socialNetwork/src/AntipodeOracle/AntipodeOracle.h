#ifndef SOCIAL_NETWORK_MICROSERVICES_ANTIPODEORACLE_H
#define SOCIAL_NETWORK_MICROSERVICES_ANTIPODEORACLE_H

#include <iostream>
#include <string>
#include <regex>
#include <future>
#include <chrono>

#include "../../gen-cpp/AntipodeOracle.h"
#include "../logger.h"
#include "../tracing.h"
#include "../ClientPool.h"
#include "../ThriftClient.h"
#include <xtrace/xtrace.h>
#include <xtrace/baggage.h>

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "AntipodeOracle.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <tbb/tbb.h>
#include <tbb/concurrent_unordered_set.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
// for clock usage
using namespace std::chrono;

namespace social_network {

  class AntipodeOracleHandler : virtual public AntipodeOracleIf {
  public:
    tbb::concurrent_unordered_set<int64_t, tbb::tbb_hash<int64_t>, std::equal_to<int>> cache;

    AntipodeOracleHandler() {
      // Your initialization goes here
    }

    bool MakeVisible(const int64_t object_id, const std::map<std::string, std::string> & carrier) {
      LOG(debug) << "[ANTIPODE] Making '" << object_id << "' visible ..." ;

      // Jaeger tracing
      TextMapReader span_reader(carrier);
      auto parent_span = opentracing::Tracer::Global()->Extract(span_reader);
      auto span = opentracing::Tracer::Global()->StartSpan(
          "MakeVisible",
          {opentracing::ChildOf(parent_span->get())});
      std::map<std::string, std::string> writer_text_map;
      TextMapWriter writer(writer_text_map);
      opentracing::Tracer::Global()->Inject(span->context(), writer);

      // save ts when notification as placed on rabbitmq
      high_resolution_clock::time_point make_visible_ts = high_resolution_clock::now();
      uint64_t ts = duration_cast<milliseconds>(make_visible_ts.time_since_epoch()).count();
      span->SetTag("make_visible_ts", std::to_string(ts));
      //

      cache.insert(object_id);

      span->Finish();
      return true;
    }

    bool IsVisible(const int64_t object_id, const std::map<std::string, std::string> & carrier) {
      LOG(debug) << "[ANTIPODE] Checking '" << object_id << "' for visibility ..." ;

      // Jaeger tracing
      TextMapReader span_reader(carrier);
      auto parent_span = opentracing::Tracer::Global()->Extract(span_reader);
      auto span = opentracing::Tracer::Global()->StartSpan(
          "IsVisible",
          {opentracing::ChildOf(parent_span->get())});
      std::map<std::string, std::string> writer_text_map;
      TextMapWriter writer(writer_text_map);
      opentracing::Tracer::Global()->Inject(span->context(), writer);

      // evaluation
      high_resolution_clock::time_point start_ts = high_resolution_clock::now();
      int attempts = 0;

      // perform operation
      tbb::concurrent_unordered_set<int64_t, tbb::tbb_hash<int64_t>, std::equal_to<int>>::iterator cacheit;
      while(true){
        attempts++;

        cacheit = cache.find(object_id);
        if (cacheit != cache.end()){
        // if(true) {
          // add metrics to span to read later
          span->SetTag("antipode_isvisible_attempts", std::to_string(attempts));

          high_resolution_clock::time_point is_visible_ts = high_resolution_clock::now();
          uint64_t ts = duration_cast<milliseconds>(is_visible_ts.time_since_epoch()).count();
          span->SetTag("is_visible_ts", std::to_string(ts));

          duration<double, std::milli> timespent = is_visible_ts - start_ts;
          span->SetTag("antipode_isvisible_duration", std::to_string(timespent.count()));
          span->Finish();

          return true;
        }
      }
      span->Finish();
      return false;
    }
  };

} // namespace social_network

#endif //SOCIAL_NETWORK_MICROSERVICES_TEXTHANDLER_H
